vxlan 虚拟扩展局域网
实现一个cni,方式很多,简单的可以是host gateway
不同节点的容器的互联互通

运行两个容器用于测试
docker run --name d1 -td burlyluo/networktoolbox
同一个网段,docker0网桥,能正常连通

(其实也不一定要自定义网络,实际上只要实现两个测试容器网段不同即可,在不同的节点上最好)
自定义容器网络,驱动用bridge,指定子网,名称
docker network create -d bridge --subnet 172.18.0.0/16 br18
(另一个节点172.20.0.0/16子网)

运行个容器使用自定义网络
docker run --name d2 --network br18 -td burlyluo/networktoolbox
(另一个几点类似)

这时候可能一个容器是172.18.0.1,一个容器172.20.0.1,没有做任何路由,这时候是不能通信
比如其中一个容器路由表,除了同网段的那就是0.0.0.0的destination,走的路由gateway是这个节点docker0网桥的ip,到了docker0网桥,查看路由表,目标地址是172.18.0.2/16网段的ip,主机没有相应的路由表记录,那就只能匹配0.0.0.0destination,gateway192.168.23.2.1,到不了,drop(ens33)
ens33 网络接口,发出的包可以前往多个目标(gateway)

设置目标容器的节点ip作为gateway 添加路由记录 route add -net 172.18.0.0/16 gw 192.168.23.2
(一般来说也是ens33,设置gw,设置下一跳,目标容器的主机ip)
数据包到了目标主机上,mac变更,ip不变,匹配路由表,docker0网桥,下一跳到docker0网桥,即可通信




github上有一个minicni,go实现